#-------------------------------------------------------------------------------
# Name:        Compile overstory and understory for determination of
#                   management canopy forest unit classification
# Purpose:      ArcPython Algorithm to generate compiled overstory, understory
#               SFU results from RIAU tool: SPCOMPParser and Populate_ForestUnit
#
# Author:      littleto
#
# Created:     26-01-2018
# Copyright:   (c) littleto 2018
# Licence:     <your licence>
#
#
# Notes:
#   Refer to onenote:///C:\Users\littleto\Documents\OneNote%20Notebooks\OMNRF%20Standard%20Forest%20Units\Standard%20Forest%20Units%20(SFU)%20Notes.one#Generate%20compiled%20SFU%20from%20RIAU%20tool&section-id={312D8DCB-9DE1-40D3-B7E5-D9523F632A0D}&page-id={0DBB2A0B-CD6D-4801-808B-3A123BDA9241}&end, for more information.
#	Originally named, "ap_compile_canopy_fu.py"
#
#-------------------------------------------------------------------------------
r"""
Compile overstory and understory for determination of management canopy forest
unit classification.

"""
import arcpy
import os
# import alert
from datetime import datetime

def print2(msg, msgtype = 'msg'):
    r""" print, arcmap AddMessage and return string all in one!

    msg = arcpy.AddMessage
    warning = arcpy.AddWarning

    A newline is added to the message string AFTER the message is sent to
    arcpy; the return includes a newline.
    """

    print(msg)
    if msgtype == 'msg':
        arcpy.AddMessage(msg)
    elif msgtype == 'warning':
        arcpy.AddWarning(msg)

    # Add newline to the message string AFTER the message is sent to arcpy; the
    # return includes a newline.
    msg = msg + '\n'

    return msg

# def chk_path(layer, path, exists):
#     """
#     Check to see of the layer files exists or not in relation to what is required.

#     layer, is the name of the layer that is being assessed for existance, or not.

#     path, os the path of layer that is being assessed for existance, or not.

#     exists, is a boolean that is the answer to the question, 'Should the layer exist?':
#         True = Yes, the layer should exist.
#         False = No, the layer should not exist.

#     NOTE:
#     Apparently, one cannot assign a data type to a function argument until Python 3.

#     Returns the messages generated by the script for a log.

#     """

#     msg = print2('Checking path...')

#     # Ensure that the 'exists' argument is the correct data type for testing.
#     if exists == True or exists == False:
#         pass
#     else:
#         msg += print2("The 'exists' argument is is not correct. It must be a boolean, either 'True' or 'False'.")
#         raise Exception(msg)

#     # Test the files on the specified path
#     # http://desktop.arcgis.com/en/arcmap/latest/analyze/arcpy-functions/exists.htm

#     pathlyr = os.path.join(path, layer)

#     if exists == True and arcpy.Exists(pathlyr) == True:
#         pass
#     elif exists == False and arcpy.Exists(pathlyr) == False:
#         pass
#     elif exists == True and arcpy.Exists(pathlyr) == False:
#         msg += print2("The '%(layer)s' layer does not exists. Specify an existing inventory layer and try again." % {"layer": pathlyr})
#         raise Exception(msg)
#     elif exists == False and arcpy.Exists(os.path.join(path, layer)) == True:
#         msg += print2("The '%(layer)s' layer exists. Remove the layer and try again." % {"layer": pathlyr})
#         raise Exception(msg)
#     else:
#         msg += print2("Other error!\n")
#         raise Exception(msg)

#     return msg


def make_a_copy(inputfc,outputfc, msg):

    msg += print2("Making a copy of the input feature class... \n\tInput: %(infc)s\n\tOutput: %(outfc)s" %{'infc':inputfc, 'outfc':outputfc})
    arcpy.FeatureClassToFeatureClass_conversion(in_features=inputfc, out_path=os.path.split(outputfc)[0], out_name=os.path.split(outputfc)[1])
    return msg



def flag_canopies(inventory, msg, os_where=""" VERT In ('SI', 'SV', 'TO', 'MO', 'CX') """, us_where=""" VERT In ('TU', 'MU') """):
    r"""
    Add a field called 'Canopy' and populate the field with according to the
    user-specified criteria for 'overstory' and 'understory'.

    inventory, is the name of the inventory.

    inventory path, is the path to the inventory. This is used to confirm the
        access to the inventory. It is a geodatabase (.GDB file).

    os_where, is the overstory where statement.

    us_where, is the understory layer name in the ArcMap project.

    Returns the messages generated by the script for a log.

    """

    # Mark the starttime
    # func_starttime = datetime.now()
    # msg += print2('Start process: %(date)s\n' % {"date": func_starttime.strftime('%Y-%m-%d %H%M')})

    # -----------------
    # Pre-flight check
    # -----------------
    # Check to make sure the layers exist if required, or don't exist if they are to be created

    # chk_path(inventory, inventory_path, True) # This check will be done on ArcMap's toolbox.

    # ------------------------------------------------
    # Add a overstory/understory flag for the records
    # ------------------------------------------------
    # Add canopy flag/source date indicator field to the overstory and understory, and calculate.

    # Determine whether or not the field already exists
    # http://desktop.arcgis.com/en/arcmap/latest/tools/data-management-toolbox/add-field.htm
    msg += print2("\nRunning flag_canopies function...")

    if len(arcpy.ListFields(inventory, "CANOPY")) > 0:  # if the canopy flag field exists, then do nothing
        msg += print2("'Canopy' field already exists")

    elif len(arcpy.ListFields(inventory, "CANOPY")) <= 0:  # if the canopy flag field does not exist, then create it.
        msg += print2("Adding 'Canopy' field")

        # Create the field if it does not already exist
        arcpy.AddField_management(inventory, "CANOPY", "TEXT", "", "", "10", "", "NULLABLE", "NON_REQUIRED", "")

        # Poplate the canopy flag field with the flag overstory or understory as appropriate
        # http://desktop.arcgis.com/en/arcmap/latest/tools/data-management-toolbox/calculate-field.htm

        temp_lyr = 'temp1'
        arcpy.MakeFeatureLayer_management(inventory, temp_lyr)

        for canopy in ["overstory", "understory", "non-forest"]:
            if canopy == "overstory":
                # Select the overstory features
                arcpy.SelectLayerByAttribute_management(temp_lyr, "NEW_SELECTION", os_where)
            elif canopy == "understory":
                # Select the understory features
                arcpy.SelectLayerByAttribute_management(temp_lyr, "NEW_SELECTION", us_where)
            elif canopy == "non-forest":
                # Select the non-forest features
                arcpy.SelectLayerByAttribute_management(temp_lyr, "NEW_SELECTION", " not (( " + os_where + " ) or ( " + us_where + " ))")

            msg += print2("Calculate the new field to '%s'." % (canopy))
            arcpy.CalculateField_management(temp_lyr, "CANOPY", "'" + canopy + "'", "PYTHON_9.3", "")

        arcpy.SelectLayerByAttribute_management(temp_lyr, "CLEAR_SELECTION")

    # msg += print2("Addition of the 'CANOPY' field and flagging of the overstory-understory for a record is compelete.")

    # check and summarize
    total_count = 0
    os_count = 0
    us_count = 0
    no_forest_count = 0
    polytype_for_count = 0
    with arcpy.da.UpdateCursor(inventory, ["CANOPY","POLYTYPE"]) as cursor:
        for row in cursor:
            total_count += 1
            val = row[0]
            if val == "overstory": os_count += 1
            elif val == "understory": us_count += 1
            elif val == "non-forest": no_forest_count += 1

            if row[1] == 'FOR': polytype_for_count += 1

    if total_count == 0:
        raise Exception('Your input has zero record!')
    unassigned_count = polytype_for_count - os_count - us_count
    if unassigned_count > 0:
        msg += print2("Your 'Define overstory' and 'Define understory' SQLs didn't cover all forested area. Check your SQLs.", 'warning')
    elif unassigned_count < 0:    
        msg += print2("Your 'Define overstory' and 'Define understory' SQLs selected some of the unforested areas. Check your SQLs.", 'warning')
    count_check = os_count + us_count + no_forest_count - total_count
    if count_check != 0:
        msg += print2("There are %s records where CANOPY value has not been assigned correctly."%count_check, 'warning')


##    msg += print2("The total of the classified records in %(total)s from the dictionary (%(dict)s)" %{"total": sum(r for r in number_of_records_dict.values()), "dict": number_of_records_dict})
    msg += print2("\nTotal num of records:\t%s"%total_count)
    msg += print2("overstory-dominant records:\t{} ({:.1f}%)".format(os_count,float(os_count)*100/total_count))
    msg += print2("understory-dominant records:\t{} ({:.1f}%)".format(us_count,float(us_count)*100/total_count))
    msg += print2("non-forest records:\t{} ({:.1f}%)".format(no_forest_count,float(no_forest_count)*100/total_count))

    # Mark the end time
    # func_endtime = datetime.now()
    # msg += print2('started: %(start)s\nended: %(end)s\nelapsed time: %(duration)s\n\n' % {'start': func_starttime, 'end': func_endtime, 'duration': (func_endtime - func_starttime).total_seconds()})

    return msg


def add_mgmt_fields(inventory, msg):
    r"""
    Add the management fields for the overstory-understory canopy.

    *** IMPORTANT ***
    This function will change the input inventory!

    A new feature class IS NOT CREATED prior to the implementing the methods of
    this function.

    *** IMPORTANT ***
    The intended input for this function is the resultant of the
    'fmp_spatial_data_compiler', because of the standardized format of the
    fields: names and data types; in short, it is FIM 2017 technical
    specification compliant.

    inventory, is the name of the inventory.

    inventory path, is the path to the inventory. This is used to confirm the
        access to the inventory. It is a geodatabase (.GDB file).

    The fields added and calculated are hard-coded:
        "MYRORG"
        "MSPCOMP"
        "MLEADSPC"
        "MAGE"
        "MHT"
        "MCCLO"
        "MSTKG"
        "MSC"

    Returns the messages generated by the script for a log.

    """

    msg += print2('\nAdding and populating Management Fields...')

    # Mark the starttime
    # func_starttime = datetime.now()
    # msg += print2('Start process: %(date)s\n' % {"date": func_starttime.strftime('%Y-%m-%d %H%M')})

    # -----------------
    # Pre-flight check
    # -----------------
    # Check to make sure the layers exist if required, or don't exist if they are to be created
    # chk_path(inventory, inventory_path, True)

    # mgmt field | TYPE  | LENGTH    | IS NULLABLE | OVERSTORY FIELD | UNDERSTORY FIELD
    mgmt_field_dict = {"MYRORG": ["SHORT", "", "NULLABLE", "OYRORG", "UYRORG"],
                       "MSPCOMP": ["TEXT", "120", "NULLABLE", "OSPCOMP", "USPCOMP"],
                       "MLEADSPC": ["TEXT", "3", "NULLABLE", "OLEADSPC", "ULEADSPC"],
                       "MAGE": ["SHORT", "", "NULLABLE", "OAGE", "UAGE"],
                       "MHT": ["FLOAT", "", "NULLABLE", "OHT", "UHT"],
                       "MCCLO": ["SHORT", "", "NULLABLE", "OCCLO", "UCCLO"],
                       # "MSTKG"     :["FLOAT", "", "NULLABLE", "OSTKG", "USTKG"],     ## Note all of the pforest in FMPDS have OSTKG and/or USTKG, all seems to have STKG.
                       "MSC": ["SHORT", "", "NULLABLE", "OSC", "USC"]
                       }

    for mgmt_field in mgmt_field_dict:
        in_table = inventory  # "bmi_201803151110_mgmt"
        field_name = mgmt_field
        field_type = mgmt_field_dict[mgmt_field][0]  # "SHORT"
        field_precision = ""
        field_scale = ""
        field_length = mgmt_field_dict[mgmt_field][1]  # ""
        field_alias = ""
        field_is_nullable = mgmt_field_dict[mgmt_field][2]  # "NULLABLE"
        field_is_required = "NON_REQUIRED"
        field_domain = ""

        # http://desktop.arcgis.com/en/arcmap/10.4/tools/data-management-toolbox/add-field.htm
        arcpy.AddField_management(in_table, field_name, field_type, field_precision, field_scale, field_length, field_alias, field_is_nullable, field_is_required, field_domain)

        msg += print2("Add field '%(field)s' completed." % {"field": mgmt_field})

        in_table = inventory
        field = mgmt_field
        expression = "canopy_attribute( !CANOPY!, !" + mgmt_field_dict[mgmt_field][3] + "!, !" + mgmt_field_dict[mgmt_field][4] + "!)"
        expression_type = "PYTHON_9.3"

        # The code_block is set to capture leading and trailing spaces in string values.
        code_block = """def canopy_attribute(canopy, overstory_value, understory_value):
                          if canopy == 'overstory' and isinstance(overstory_value, (basestring)):
                            return overstory_value.strip()
                          elif canopy == 'understory' and isinstance(understory_value, (basestring)):
                            return understory_value.strip()
                          elif canopy == 'overstory':
                            return overstory_value
                          elif canopy == 'understory':
                            return understory_value
                          elif isinstance(overstory_value, (int, float, long)) or isinstance(understory_value, (int, float, long)):
                            return 0
                          elif isinstance(overstory_value, (basestring)) or isinstance(understory_value, (basestring)):
                            return ''
                          elif overstory == None and understory == None:
                            return ''
                          else:
                            pass
                        """

        # http://desktop.arcgis.com/en/arcmap/10.4/tools/data-management-toolbox/calculate-field.htm
        arcpy.CalculateField_management(in_table, field, expression, expression_type, code_block)

        msg += print2("Calculate field '%(field)s' completed." % {"field": mgmt_field})

    msg += print2("Addition of the 'management canopy' fields is compelete.")

    # Mark the end time
    # func_endtime = datetime.now()
    # msg += print2('started: %(start)s\nended: %(end)s\nelapsed time: %(duration)s\n\n' % {'start': func_starttime, 'end': func_endtime, 'duration': (func_endtime - func_starttime).total_seconds()})

    return msg


# def summarize(in_table, out_path, out_table, statistics_fields=[["Shape_area", "SUM"]], case_field=["CANOPY"]):
#     """
#     Still in development. Not sure how I plan to get the forest unit field name
#     into this module automatically. Fortunately, the CANOPY  is standardized.

#     Returns the messages generated by the script for a log.

#     """

#     msg = print2('\nSummarizing...\n')

#     # Check to make sure the layers exist if required, or don't exist if they are to be created
#     chk_path(in_table, out_path, True)
#     chk_path(out_table, out_path, False)

#     msg += print2('The input table: %s\n' % in_table)
#     msg += print2('The output path: %s\n' % out_path)
#     msg += print2('The output table %s\n' % out_table)
#     msg += print2('Statistics: %s\n' % statistics_fields)
#     msg += print2('Cases: %s\n' % case_field)

#     # Calculate the summary statistics
#     # http://desktop.arcgis.com/en/arcmap/latest/tools/analysis-toolbox/summary-statistics.htm
#     ##  xxx.summarize(newfc, outpath, newfc + "_summary", [["Shape_area", "SUM"]],["CANOPY", "NER_GLSL_SFU_withEcosite", "Ecosite_GeoRangeAndNumber"])
#     arcpy.Statistics_analysis(in_table, os.path.join(out_path, out_table), statistics_fields, case_field)
#     msg += print2('Completed analysis...\n')

#     # Add AREA_HA field
#     #   http://desktop.arcgis.com/en/arcmap/10.4/tools/data-management-toolbox/add-field.htm
#     arcpy.AddField_management(os.path.join(out_path, out_table), "AREA_HA", "SINGLE", "", "", "", "", "", "", "")

#     # Calculates the AREA_HA field
#     #   http://desktop.arcgis.com/en/arcmap/10.4/tools/data-management-toolbox/calculate-field.htm
#     arcpy.CalculateField_management(os.path.join(out_path, out_table), "AREA_HA", "!SUM_Shape_area!/10000", "PYTHON_9.3", "")
#     msg += print2('Completed calculation of area in hectares, based on the projection provided.\n')

#     # Delete unnecessasry fields
#     #   http://desktop.arcgis.com/en/arcmap/10.4/tools/data-management-toolbox/delete-field.htm
#     #   Remember the output is a output dBASE or geodatabase table that will store the calculated statistics.
#     #   DeleteField_management (in_table, drop_field)
#     arcpy.DeleteField_management(os.path.join(out_path, out_table), "SUM_Shape_area")
#     msg += print2("Completed clean up of the 'SUM' field.\n")

#     # Alert the user of the completion of the task with a winsound.
#     alert.alert()

#     msg += print2("... summary result in '%s'\n" % (os.path.join(out_path, out_table)))

#     return msg


if __name__ == '__main__':

    # *** Technically I still need to use the MakeFeatureLayer for the
    #       overstory and the understory to run this as a stand alone script.
    #       At the moment the script is intended to be used within an ESRI
    #       ArcGIS map document by calling the module. Use the Python Window
    #       "Load" on the popup menu (right click).

    inputfc = arcpy.GetParameterAsText(0)
    outputfc = arcpy.GetParameterAsText(1)
    os_sql = arcpy.GetParameterAsText(2) # VERT In ('SI', 'SV', 'TO', 'MO', 'CX') 
    us_sql = arcpy.GetParameterAsText(3) # VERT In ('TU', 'MU')



    msg = ''
    msg += make_a_copy(inputfc,outputfc,msg)
    msg += flag_canopies(outputfc,msg,os_sql,us_sql)
    msg += add_mgmt_fields(outputfc,msg)






